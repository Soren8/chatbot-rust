<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no">
    <title>AI Chat</title>
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body class="d-flex flex-column vh-100 bg-dark text-light">
    <!-- Bootstrap Navbar for header controls -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <button id="settings-toggle" class="btn btn-outline-light me-2" type="button" data-bs-toggle="collapse" data-bs-target="#settingsCollapse" aria-controls="settingsCollapse" aria-expanded="false" aria-label="Toggle settings">
                <i class="bi bi-gear-fill" aria-hidden="true"></i>
            </button>
            <span class="navbar-brand navbar-brand-center">AI Chat</span>
            <div class="navbar-nav ms-auto d-flex flex-row align-items-center flex-nowrap gap-3">
                {% if logged_in %}
                <a class="nav-link" href="/logout">Sign Out</a>
                {% else %}
                <a class="nav-link" href="/login">Login</a>
                {% endif %}
            </div>
        </div>
    </nav>
    
    <!-- Premium alert banner -->
    <div id="premium-alert" class="alert alert-warning alert-dismissible fade show m-3" role="alert" style="display: none;">
        ðŸ”’ This model requires a <a href="/upgrade" class="alert-link">Premium Account</a>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>

    <!-- Main layout: settings panel (collapsible) + chat area -->
    <div class="container-fluid flex-grow-1 d-flex flex-column h-100 mt-2">
        <div class="row g-0 flex-grow-1 h-100">
            <!-- Settings column: collapse inside column so it can push content on small screens -->
            <div id="settings-col" class="col-12 col-md-4">
                <div id="settingsCollapse" class="collapse p-3">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="mb-0">Settings</h5>
                        <span class="navbar-text ms-auto d-none d-md-inline">Account:
                            <span class="badge bg-{% if user_tier == 'premium' %}success{% else %}secondary{% endif %}">{{ 'Premium' if user_tier == 'premium' else 'Free' }}</span>
                        </span>
                        <span class="navbar-text ms-2 d-inline d-md-none">Account:
                            <span class="badge bg-{% if user_tier == 'premium' %}success{% else %}secondary{% endif %}">{{ 'Premium' if user_tier == 'premium' else 'Free' }}</span>
                        </span>
                    </div>

                    {% if logged_in %}
                    <div class="mb-3">
                        <div class="row g-2 align-items-center mb-2">
                            <label class="col-3 col-form-label mb-0 text-start">Model</label>
                            <div class="col-9">
                                <select id="modelSelect" class="form-select" onchange="validateModelTier()">
                                    {% for llm in available_llms %}
                                    <option value="{{ llm.provider_name }}" data-tier="{{ llm.tier }}">{{ llm.provider_name }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                        </div>

                        <div class="row g-2 align-items-center mb-2">
                            <label class="col-3 col-form-label mb-0 text-start">Set</label>
                            <div class="col-9">
                                <select id="set-selector" class="form-select">
                                    <option value="default">Default Set</option>
                                </select>
                            </div>
                        </div>
                        <div class="d-flex gap-2 mb-2">
                            <button id="new-set" class="btn btn-outline-primary">New</button>
                            <button id="delete-set" class="btn btn-outline-danger">Delete</button>
                            <button id="reset-chat" class="btn btn-outline-warning ms-auto">Reset Chat</button>
                        </div>
                    </div>
                    {% endif %}

                    <div class="settings-cards d-flex flex-column gap-3">
                        <div class="card mb-0">
                        <div class="card-header">
                            <h6 class="mb-0">System Prompt</h6>
                        </div>
                        <div class="card-body">
                            <textarea id="user-system-prompt" class="form-control" placeholder="User system prompt here..." rows="7"></textarea>
                            <button id="save-system-prompt" class="btn btn-outline-primary mt-2 w-100">Save</button>
                        </div>
                        </div>

                        <div class="card mb-0">
                        <div class="card-header">
                            <h6 class="mb-0">Memory</h6>
                        </div>
                        <div class="card-body">
                            <textarea id="user-memory" class="form-control" placeholder="User memory here..." rows="7"></textarea>
                            <button id="save-memory" class="btn btn-outline-primary mt-2 w-100">Save</button>
                        </div>
                        </div>
                    </div>
                </div>
            </div>

    <!-- Chat Container -->
            <div id="chat-area" class="col-12 col-md-8 d-flex flex-column p-3">
                <div id="chat-box" class="card flex-grow-1 mb-3">
                    <div id="chat-content" class="card-body overflow-auto"></div>
                </div>
                <div class="input-group">
                    <input type="text" id="user-input" class="form-control" placeholder="Type your message here...">
                    <button class="btn btn-outline-primary" type="button" id="send-button">Send</button>
                </div>
            </div>
        </div>
    </div>

    
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Show settings by default on md+ screens, collapse by default on small screens
        document.addEventListener('DOMContentLoaded', function() {
            try {
                var collapseEl = document.getElementById('settingsCollapse');
                var settingsCol = document.getElementById('settings-col');
                var chatArea = document.getElementById('chat-area');
                if (!collapseEl || !settingsCol || !chatArea) return;

                var bsCollapse = bootstrap.Collapse.getOrCreateInstance(collapseEl, {toggle:false});

                function applyState(open) {
                    // When the settings collapse is closed, hide the settings column on ALL sizes
                    if (!open) {
                        settingsCol.classList.add('d-none');
                    } else {
                        settingsCol.classList.remove('d-none');
                    }

                    // Adjust chat area width on md+ when settings are shown/hidden
                    if (window.innerWidth >= 768) {
                        if (!open) {
                            chatArea.classList.remove('col-md-8');
                            chatArea.classList.add('col-md-12');
                        } else {
                            chatArea.classList.remove('col-md-12');
                            chatArea.classList.add('col-md-8');
                        }
                    } else {
                        // On small screens ensure chat area uses the md-8 class for consistency when switching
                        chatArea.classList.remove('col-md-12');
                        chatArea.classList.add('col-md-8');
                    }
                }

                // Initialize based on viewport
                if (window.innerWidth >= 768) {
                    bsCollapse.show();
                } else {
                    bsCollapse.hide();
                }
                applyState(bsCollapse._isShown || collapseEl.classList.contains('show'));

                collapseEl.addEventListener('shown.bs.collapse', function() { applyState(true); });
                collapseEl.addEventListener('hidden.bs.collapse', function() { applyState(false); });

                // On resize ensure visible on md+ and update layout
                window.addEventListener('resize', function() {
                    if (window.innerWidth >= 768) bsCollapse.show();
                    applyState(collapseEl.classList.contains('show'));
                });
            } catch (e) { console.debug('settings collapse init error', e); }
        });
    </script>

    <script>
        // Ensure input stays visible on mobile when focusing the keyboard
        document.addEventListener('DOMContentLoaded', function() {
            try {
                var input = document.getElementById('user-input');
                var chatBox = document.getElementById('chat-box');
                if (!input || !chatBox) return;

                function updateInputHeight() {
                    try {
                        var h = input.getBoundingClientRect().height || 56;
                        document.documentElement.style.setProperty('--chat-input-height', h + 'px');
                        // Ensure chat box padding accounts for the input
                        chatBox.style.paddingBottom = 'calc(' + h + 'px + env(safe-area-inset-bottom, 0))';
                    } catch (e) {}
                }

                input.addEventListener('focus', function() {
                    // update heights and scroll input into view after keyboard appears
                    updateInputHeight();
                    setTimeout(function() {
                        try { input.scrollIntoView({block: 'center'}); } catch (e) {}
                    }, 300);
                });

                // Also update on orientation change / resize
                window.addEventListener('resize', updateInputHeight);
                updateInputHeight();
            } catch (e) { console.debug('mobile input helper error', e); }
        });
    </script>

<script>
    function escapeHTML(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }

    // App configuration data
    const APP_DATA = {
        userTier: "{{ user_tier }}",
        availableModels: {{ available_llms|default([])|tojson }}
    };

    // Track currently playing audio and its control button so we can stop it
    let CURRENT_AUDIO = null;
    let CURRENT_AUDIO_BUTTON = null;

    function disablePremiumModels() {
        const $selector = $('#modelSelect');
        if ($selector.length === 0) return;
        
        $selector.find('option').each(function() {
            const isPremium = $(this).data('tier') === 'premium';
            // Remove disabled property to allow selection while maintaining visual styling
            $(this).css('opacity', isPremium && APP_DATA.userTier !== 'premium' ? '0.6' : '1');
        });
    }

    let previousModel = 'default';
    
    function validateModelTier() {
        const $selected = $('#modelSelect option:checked');
        const $premiumAlert = $('#premium-alert');
        const $modelSelect = $('#modelSelect');
        
        if($selected.data('tier') === 'premium' && APP_DATA.userTier !== 'premium') {
            $premiumAlert.show();
            setTimeout(() => $premiumAlert.hide(), 3000);
            $modelSelect.val(previousModel);
            // Add visual feedback by temporarily highlighting the dropdown
            $modelSelect.css('backgroundColor', '#3a1a1a');
            setTimeout(() => {
                $modelSelect.css('backgroundColor', '#2c3e50');
            }, 500);
        } else {
            $premiumAlert.hide();
            $modelSelect.css('backgroundColor', '#2c3e50');
        }
        previousModel = $modelSelect.val();
    }
    

    function regenerateMessage(button) {
        const $aiMessageElement = $(button).closest('.message');
        const $previousUserMessage = $aiMessageElement.prev('.message.user-message');
        
        if ($previousUserMessage.length > 0) {
            // Ensure we only extract the user's message text, not any UI (like the trashcan emoji)
            const $userMessageSpan = $previousUserMessage.find('.user-message-text');
            const userMessage = ($userMessageSpan.length ? $userMessageSpan.text() : $previousUserMessage.text()).replace('You:', '').trim();
            
            const activeSet = $('#set-selector').val() || 'default';
            
            // Reset the AI message area for regeneration
            $aiMessageElement.html(`<strong>AI:</strong><div class="thinking-container" style="display:none;"><button class="toggle-thinking" onclick="toggleThinking(this)">â–¶ Show Thinking</button><div class="thinking-content" style="display:none;"></div></div><span class="ai-message-text">Thinking...</span><div class="regenerate-container"><button class="regenerate-button" onclick="regenerateMessage(this)" disabled><i class="bi bi-arrow-repeat"></i></button><button class="play-button" onclick="playTTS(this)" disabled><i class="bi bi-play-fill"></i></button></div>`);
            
            fetch('/regenerate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: userMessage,
                    system_prompt: $('#user-system-prompt').val(),
                    set_name: activeSet,
                    model_name: $('#modelSelect').val()
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => { 
                        throw new Error(text || 'Network response was not ok'); 
                    });
                }
                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');

                const messageTextElement = aiMessageElement.querySelector('.ai-message-text');
                const thinkingContainerWrapper = aiMessageElement.querySelector('.thinking-container');
                const thinkingContentElement = aiMessageElement.querySelector('.thinking-content');
                
                let buffer = '';
                let state = 'visible'; // 'visible' or 'thinking'
                let hasWrittenToDOM = false;

                function processChunk(chunk) {
                    buffer += chunk;
                    console.debug(`[CHUNK] Received: ${JSON.stringify(chunk)}, Buffer: ${JSON.stringify(buffer)}`);

                    while (buffer.length > 0) {
                        if (state === 'visible') {
                            const tagStart = buffer.indexOf('<think>');
                            if (tagStart !== -1) {
                                const visiblePart = buffer.substring(0, tagStart);
                                appendVisible(visiblePart);
                                buffer = buffer.substring(tagStart + '<think>'.length);
                                state = 'thinking';
                                continue; // Re-run loop with new state and buffer
                            } else {
                                // No complete start tag. Check for a partial tag at the end.
                                let flushableEnd = buffer.length;
                                for (let i = 1; i <= buffer.length && i <= '<think>'.length; i++) {
                                    const suffix = buffer.substring(buffer.length - i);
                                    if ('<think>'.startsWith(suffix)) {
                                        flushableEnd = buffer.length - i;
                                        break;
                                    }
                                }
                                const visiblePart = buffer.substring(0, flushableEnd);
                                appendVisible(visiblePart);
                                buffer = buffer.substring(flushableEnd);
                                break; // Wait for more chunks
                            }
                        } else if (state === 'thinking') {
                            const tagEnd = buffer.indexOf('</think>');
                            if (tagEnd !== -1) {
                                const thinkingPart = buffer.substring(0, tagEnd);
                                appendThinking(thinkingPart);
                                buffer = buffer.substring(tagEnd + '</think>'.length);
                                state = 'visible';
                                continue; // Re-run loop
                            } else {
                                // No end tag. Check for partial end tag.
                                let flushableEnd = buffer.length;
                                for (let i = 1; i <= buffer.length && i <= '</think>'.length; i++) {
                                    const suffix = buffer.substring(buffer.length - i);
                                    if ('</think>'.startsWith(suffix)) {
                                        flushableEnd = buffer.length - i;
                                        break;
                                    }
                                }
                                const thinkingPart = buffer.substring(0, flushableEnd);
                                appendThinking(thinkingPart);
                                buffer = buffer.substring(flushableEnd);
                                break; // Wait for more chunks
                            }
                        }
                    }
                }

                function appendVisible(content) {
                    if (!content) return;
                    console.debug(`[VISIBLE] Appending: ${JSON.stringify(content)}`);
                    if (!hasWrittenToDOM) {
                        // Use textContent to avoid HTML rendering issues and ensure streamed text is visible
                        messageTextElement.textContent = content;
                        hasWrittenToDOM = true;
                    } else {
                        messageTextElement.textContent += content;
                    }
                }

                function appendThinking(content) {
                    if (!content) return;
                    console.debug(`[THINKING] Appending: ${JSON.stringify(content)}`);
                    if (!hasWrittenToDOM) {
                        messageTextElement.textContent = ''; // Clear "Thinking..."
                        hasWrittenToDOM = true;
                    }
                    thinkingContainerWrapper.style.display = 'block';
                    thinkingContentElement.textContent += content;
                }

                function readStream() {
                    return reader.read().then(({ done, value }) => {
                        if (done) {
                            // If the stream ends, process any remaining buffer content.
                            if (buffer) {
                                if (state === 'thinking') appendThinking(buffer);
                                else appendVisible(buffer);
                                buffer = '';
                            }
                            const buttons = aiMessageElement.querySelectorAll('.regenerate-button, .play-button');
                            buttons.forEach(b => { b.disabled = false; });
                            return;
                        }
                        const chunk = decoder.decode(value, { stream: true });
                       processChunk(chunk);
                       
                const $chatBox = $('#chat-box');
                // Determine if we should auto-scroll while streaming: only if the user
                // was already at (or near) the bottom before streaming started.
                const __autoScroll = ($chatBox.scrollTop() + $chatBox.innerHeight() >= $chatBox[0].scrollHeight - 50);
                if (__autoScroll) { $chatBox.scrollTop($chatBox[0].scrollHeight); }

                        return readStream();
                    });
                }
                
                readStream().catch(error => {
                    console.error('Error reading stream:', error);
                    aiMessageElement.innerHTML = `<strong>AI:</strong> <span class="error-message">[Error] ${error.message}</span>\n\n<div class="regenerate-container"><button class="regenerate-button" onclick="regenerateMessage(this)">âŸ³ Regenerate</button></div>`;
                });
            })
            .catch(error => {
                console.error('Fetch error:', error);
                aiMessageElement.innerHTML = `<strong>AI:</strong> <span class="error-message">Error: ${escapeHTML(error.message)}</span>\n\n<div class="regenerate-container"><button class="regenerate-button" onclick="regenerateMessage(this)">âŸ³ Regenerate</button></div>`;
            });
        }
    }

    $(document).ready(function() {
        disablePremiumModels(); // Initialize model disabling
        // Add event delegation for play and delete buttons
        $(document).on('click', function(event) {
            const target = event.target;
            if (target.classList.contains('play-button')) {
                console.debug("[TTS] Play button click detected via event delegation");
                playTTS(target);
                return;
            }

            const deleteBtn = target.closest('.delete-button');
            if (deleteBtn) {
                console.debug("[DELETE] Delete button clicked via event delegation");
                const userMessageElement = deleteBtn.closest('.message.user-message');
                if (!userMessageElement) return;

                // Find the corresponding AI message (assumed to be the immediate next sibling)
                const aiMessageElement = userMessageElement.nextElementSibling && userMessageElement.nextElementSibling.classList.contains('ai-message')
                    ? userMessageElement.nextElementSibling
                    : null;

                // Extract plain text for server-side deletion
                const userText = (userMessageElement.querySelector('.user-message-text')?.textContent || '').replace('You:', '').trim();
                const aiText = aiMessageElement ? (aiMessageElement.querySelector('.ai-message-text')?.textContent || '').trim() : '';

                // Remove from DOM immediately for responsive UI
                if (aiMessageElement) aiMessageElement.remove();
                userMessageElement.remove();

                // Send deletion request to server to persist removal from session history (best-effort)
                fetch('/delete_message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_message: userText,
                        ai_message: aiText,
                       set_name: $('#set-selector').val() || 'default'
                   })
                })
                .then(response => {
                    if (!response.ok) {
                        console.error("[DELETE] Server failed to delete message pair");
                    } else {
                        console.debug("[DELETE] Server delete confirmed");
                    }
                })
                .catch(err => {
                    console.error("[DELETE] Delete request failed:", err);
                });
            }
        });
        {% if logged_in %}
        // Load available sets
        function loadSets() {
            return fetch('/get_sets')
            .then(response => response.json())
            .then(data => {
                const $selector = $('#set-selector');
                $selector.empty(); // Clear existing options
                // Server returns an object mapping setName -> metadata, so iterate keys
                $.each(data, function(setName, meta) {
                    $selector.append(`<option value="${setName}">${setName}</option>`);
                });
                // After loading sets, trigger a change event to load the default set
                $selector.trigger('change');
            });
        }

        // Load initial sets
        loadSets();
        {% endif %}

        {% if logged_in %}
        // Handle set selection change
        $('#set-selector').on('change', function() {
            const setName = $(this).val();
            console.log(`Loading set: ${setName}`);
            
            fetch('/load_set', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ set_name: setName })
            })
            .then(response => {
                if (!response.ok) {
                    console.error('Network response not OK:', response.status);
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Received set data:', data);
                
                $('#user-system-prompt').val(data.system_prompt || '');
                $('#user-memory').val(data.memory || '');
                
                // Clear existing chat
                $('#chat-content').empty();
                
                // Load chat history
                if (data.history && data.history.length > 0) {
                    console.log(`Loading ${data.history.length} history items`);
                    data.history.forEach(([userMsg, aiMsg]) => {
                        appendMessage('<strong>You:</strong> ' + escapeHTML(userMsg), 'user-message');
                        appendMessage(
                            `<strong>AI:</strong>&nbsp;<span class="ai-message-text">${escapeHTML(aiMsg)}</span>
                            <div class="regenerate-container">
                                <button class="regenerate-button" onclick="regenerateMessage(this)"><i class="bi bi-arrow-repeat"></i></button>
                                <button class="play-button" onclick="playTTS(this)"><i class="bi bi-play-fill"></i></button>
                            </div>`,
                            'ai-message'
                        );
                    });
                    // After loading history, ensure chat is scrolled to the bottom
                    setTimeout(function() {
                        try { $('#chat-box').scrollTop($('#chat-box')[0].scrollHeight); } catch (e) { console.debug('scroll to bottom failed', e); }
                    }, 0);
                }
                
                appendMessage('<strong>System:</strong> Loaded set: ' + setName, 'system-message');
            })
            .catch(error => {
                console.error('Error loading set:', error);
                appendMessage('<strong>Error:</strong> Failed to load set: ' + error.message, 'error-message');
            });
        });

        // Handle new set creation
        $('#new-set').on('click', function() {
            const setName = prompt('Enter name for new set:');
            if (setName) {
                fetch('/create_set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ set_name: setName })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        // Reload sets and automatically select the new one
                        loadSets().then(() => {
                            // Set the selector to the new set
                            $('#set-selector').val(setName);
                            // Trigger change event to load the set
                            $('#set-selector').trigger('change');
                        });
                        appendMessage('<strong>System:</strong> Created new set: ' + setName, 'system-message');
                    } else {
                        appendMessage('<strong>Error:</strong> ' + data.error, 'error-message');
                    }
                });
            }
        });

        // Handle set deletion
        $('#delete-set').on('click', function() {
            const setName = $('#set-selector').val();
            if (setName === 'default') {
                appendMessage('<strong>Error:</strong> Cannot delete default set', 'error-message');
                return;
            }
            if (confirm('Are you sure you want to delete set: ' + setName + '?')) {
                fetch('/delete_set', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ set_name: setName })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        loadSets();
                        // After deletion, load the default set
                        fetch('/load_set', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ set_name: 'default' })
                        })
                        .then(response => response.json())
                        .then(data => {
                            $('#user-system-prompt').val(data.system_prompt);
                            $('#user-memory').val(data.memory);
                            $('#set-selector').val('default');
                            appendMessage('<strong>System:</strong> Deleted set: ' + setName + '. Loaded default set.', 'system-message');
                        });
                    }
                });
            }
        });
        {% endif %}
        function appendMessage(message, className) {
            const $chatContent = $('#chat-content');
            const $messageElement = $('<div>').addClass('message ' + className);
            
            if (className && className.indexOf('user-message') !== -1) {
                $messageElement.html(`<span class="user-message-text">${message}</span>`);
            } else {
                $messageElement.html(message);
            }

            // If this is a user message, add a delete (trash) button
            if (className && className.indexOf('user-message') !== -1) {
                try {
                    const $deleteContainer = $('<div>').addClass('regenerate-container');
                    const $deleteBtn = $('<button>')
                        .attr('type', 'button')
                        .addClass('delete-button')
                        .attr('title', 'Delete message')
                        .html('<span class="delete-icon"><i class="bi bi-trash-fill"></i></span>');
                    $deleteContainer.append($deleteBtn);
                    $messageElement.append($deleteContainer);
                } catch (e) {
                    console.debug("Failed to add delete button:", e);
                }
            }

            $chatContent.append($messageElement);
                const $chatBox = $('#chat-box');
                // Respect the auto-scroll preference detected when streaming began
                if (typeof __autoScroll !== 'undefined' ? __autoScroll : ($chatBox.scrollTop() + $chatBox.innerHeight() >= $chatBox[0].scrollHeight - 50)) {
                    $chatBox.scrollTop($chatBox[0].scrollHeight);
                }
        }



        function playTTS(button) {
            console.debug("[TTS] Play button clicked");
            console.debug("[TTS] Button element:", button);

            // If this button controls the currently playing audio => stop it
            if (CURRENT_AUDIO && CURRENT_AUDIO_BUTTON === button) {
                console.debug("[TTS] Stopping current audio via same button");
                try {
                    CURRENT_AUDIO.pause();
                    CURRENT_AUDIO.currentTime = 0;
                } catch (e) {
                    console.debug("[TTS] Error stopping audio:", e);
                }
                if (CURRENT_AUDIO_BUTTON) {
                    $(CURRENT_AUDIO_BUTTON).removeClass('playing').prop('disabled', false).html('<i class="bi bi-play-fill"></i>');
                }
                CURRENT_AUDIO = null;
                CURRENT_AUDIO_BUTTON = null;
                return;
            }

            // If another audio is playing, stop it and reset its button
            if (CURRENT_AUDIO) {
                console.debug("[TTS] Stopping previously playing audio");
                try {
                    CURRENT_AUDIO.pause();
                    CURRENT_AUDIO.currentTime = 0;
                } catch (e) {
                    console.debug("[TTS] Error stopping previous audio:", e);
                }
                if (CURRENT_AUDIO_BUTTON) {
                    $(CURRENT_AUDIO_BUTTON).removeClass('playing').prop('disabled', false).html('<i class="bi bi-play-fill"></i>');
                }
                CURRENT_AUDIO = null;
                CURRENT_AUDIO_BUTTON = null;
            }
            
            const $messageElement = $(button).closest('.message');
            console.debug("[TTS] Message element:", $messageElement);

            const messageText = $messageElement.find('.ai-message-text').text() || '';
            console.debug("[TTS] Message text extracted:", messageText);

            if (!messageText) {
                console.error("[TTS] No text found to play");
                return;
            }

            // Disable button while fetching audio
                $(button).prop('disabled', true).text("...");
            console.debug("[TTS] Button disabled and loading state set");

            fetch('/tts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    text: messageText
                })
            })
            .then(response => {
                console.debug("[TTS] Response received, status:", response.status);
                if (!response.ok) {
                    console.error("[TTS] Network response not OK:", response.statusText);
                    throw new Error('Network response was not ok');
                }
                return response.blob();
            })
            .then(blob => {
                console.debug("[TTS] Audio blob received");
                const audioUrl = URL.createObjectURL(blob);
                const audio = new Audio(audioUrl);
    
                // Track globally so we can stop it from other buttons
                CURRENT_AUDIO = audio;
                CURRENT_AUDIO_BUTTON = button;
    
                // Enable the button so it can be used to stop playback, and show Stop icon
                $(button).prop('disabled', false).addClass('playing').html('<i class="bi bi-stop-fill"></i>');
    
                console.debug("[TTS] Audio element created, playing...");
                audio.play().catch(err => {
                    console.error("[TTS] Audio play failed:", err);
                });
    
                // When playback ends naturally, reset button/UI
                audio.addEventListener('ended', () => {
                    console.debug("[TTS] Audio playback ended");
                    if (CURRENT_AUDIO_BUTTON) {
                        $(CURRENT_AUDIO_BUTTON).removeClass('playing').prop('disabled', false).html('<i class="bi bi-play-fill"></i>');
                    }
                    try { URL.revokeObjectURL(audioUrl); } catch (e) {}
                    CURRENT_AUDIO = null;
                    CURRENT_AUDIO_BUTTON = null;
                });
    
                // If the audio is paused/stopped elsewhere, ensure UI is reset
                audio.addEventListener('pause', () => {
                    if (CURRENT_AUDIO_BUTTON) {
                        $(CURRENT_AUDIO_BUTTON).removeClass('playing').prop('disabled', false).html('<i class="bi bi-play-fill"></i>');
                    }
                });
            })
            .catch(error => {
                console.error("[TTS] Error:", error);
                $(button).prop('disabled', false).html('<i class="bi bi-play-fill"></i>').removeClass('playing');
                alert('Error playing audio: ' + error.message);
            });
        }

        function escapeHTML(str) {
            var div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
        }

        $('#toggle-config').on('click', function() {
            $('#config-container').collapse('toggle');
        });

        $('#save-system-prompt').on('click', function() {
            const sysPromptText = $('#user-system-prompt').val();
            const setName = $('#set-selector').val() || 'default';
            
            fetch('/update_system_prompt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    system_prompt: sysPromptText,
                    set_name: setName
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success') {
                    appendMessage('<strong>System:</strong> System prompt saved successfully.', 'system-message');
                    console.debug('System prompt saved successfully');
                } else {
                    appendMessage('<strong>Error:</strong> Failed to save system prompt.', 'error-message');
                    console.error('Failed to save system prompt');
                }
            })
            .catch(error => {
                appendMessage('<strong>Error:</strong> ' + escapeHTML(error.message), 'error-message');
                console.error('Error saving system prompt:', error);
            });
        });

        $('#save-memory').on('click', function() {
            const memText = $('#user-memory').val();
            const setName = $('#set-selector').val() || 'default';
            
            fetch('/update_memory', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    memory: memText,
                    set_name: setName
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    appendMessage('<strong>System:</strong> Memory saved successfully.', 'system-message');
                } else {
                    appendMessage('<strong>Error:</strong> Failed to save memory.', 'error-message');
                }
            })
            .catch(error => {
                appendMessage('<strong>Error:</strong> ' + escapeHTML(error.message), 'error-message');
            });
        });

        function sendMessage() {
            // Get required elements
            const $systemPromptElement = $('#user-system-prompt');
            const $userInputElement = $('#user-input');
    
            // Basic validation - these elements should always exist
            if ($systemPromptElement.length === 0 || $userInputElement.length === 0) {
                console.error("Critical chat elements missing!");
                appendMessage('<strong>Error:</strong> Chat system not properly initialized. Please refresh the page.', 'error-message');
                return;
            }

            const message = $userInputElement.val().trim();
    
            // Validate message
            if (!message) {
                console.warn("Message cannot be empty!");
                return;
            }

            // Get values
            const systemPrompt = $systemPromptElement.val() || {{ Config.DEFAULT_SYSTEM_PROMPT | tojson }};
            const $setSelector = $('#set-selector');
            const activeSet = $setSelector.val() || 'default';

            // Clear input
            $userInputElement.val('');

            // Add user message to chat
            appendMessage('<strong>You:</strong> ' + escapeHTML(message), 'user-message');

            // Prepare request data
            const requestData = {
                message: message,
                system_prompt: systemPrompt,
                set_name: activeSet,
                model_name: $('#modelSelect').val()
            };

            // Send to backend
            fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => { 
                        throw new Error(text || 'Network response was not ok'); 
                    });
                }
                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');

                // Add AI message placeholder with thinking container
                appendMessage(
                    `<strong>AI:</strong><div class="thinking-container" style="display:none;"><button class="toggle-thinking" onclick="toggleThinking(this)">â–¶ Show Thinking</button><div class="thinking-content" style="display:none;"></div></div><span class="ai-message-text">Thinking...</span><div class="regenerate-container"><button class="regenerate-button" onclick="regenerateMessage(this)" disabled><i class="bi bi-arrow-repeat"></i></button><button class="play-button" onclick="playTTS(this)" disabled><i class="bi bi-play-fill"></i></button></div>`,
                    'ai-message'
                );
                const $targetElement = $('.ai-message:last-child');
                // Use jQuery objects so appendVisible/appendThinking can use jQuery APIs
                const $messageTextElement = $targetElement.find('.ai-message-text');
                const $thinkingContainerWrapper = $targetElement.find('.thinking-container');
                const $thinkingContentElement = $targetElement.find('.thinking-content');

                let buffer = '';
                let state = 'visible'; // 'visible' or 'thinking'
                let hasWrittenToDOM = false;

                function processChunk(chunk) {
                    buffer += chunk;
                    console.debug(`[CHUNK] Received: ${JSON.stringify(chunk)}, Buffer: ${JSON.stringify(buffer)}`);

                    while (buffer.length > 0) {
                        if (state === 'visible') {
                            const tagStart = buffer.indexOf('<think>');
                            if (tagStart !== -1) {
                                const visiblePart = buffer.substring(0, tagStart);
                                appendVisible(visiblePart);
                                buffer = buffer.substring(tagStart + '<think>'.length);
                                state = 'thinking';
                                continue; // Re-run loop with new state and buffer
                            } else {
                                // No complete start tag. Check for a partial tag at the end.
                                let flushableEnd = buffer.length;
                                for (let i = 1; i <= buffer.length && i <= '<think>'.length; i++) {
                                    const suffix = buffer.substring(buffer.length - i);
                                    if ('<think>'.startsWith(suffix)) {
                                        flushableEnd = buffer.length - i;
                                        break;
                                    }
                                }
                                const visiblePart = buffer.substring(0, flushableEnd);
                                appendVisible(visiblePart);
                                buffer = buffer.substring(flushableEnd);
                                break; // Wait for more chunks
                            }
                        } else if (state === 'thinking') {
                            const tagEnd = buffer.indexOf('</think>');
                            if (tagEnd !== -1) {
                                const thinkingPart = buffer.substring(0, tagEnd);
                                appendThinking(thinkingPart);
                                buffer = buffer.substring(tagEnd + '</think>'.length);
                                state = 'visible';
                                continue; // Re-run loop
                            } else {
                                // No end tag. Check for partial end tag.
                                let flushableEnd = buffer.length;
                                for (let i = 1; i <= buffer.length && i <= '</think>'.length; i++) {
                                    const suffix = buffer.substring(buffer.length - i);
                                    if ('</think>'.startsWith(suffix)) {
                                        flushableEnd = buffer.length - i;
                                        break;
                                    }
                                }
                                const thinkingPart = buffer.substring(0, flushableEnd);
                                appendThinking(thinkingPart);
                                buffer = buffer.substring(flushableEnd);
                                break; // Wait for more chunks
                            }
                        }
                    }
                }

                function appendVisible(content) {
                    if (!content) return;
                    console.debug(`[VISIBLE] Appending: ${JSON.stringify(content)}`);
                    if (!hasWrittenToDOM) {
                        $messageTextElement.text(content);
                        hasWrittenToDOM = true;
                    } else {
                        // append as text to avoid HTML interpretation
                        $messageTextElement.text($messageTextElement.text() + content);
                    }
                }

                function appendThinking(content) {
                    if (!content) return;
                    console.debug(`[THINKING] Appending: ${JSON.stringify(content)}`);
                    if (!hasWrittenToDOM) {
                        $messageTextElement.text(''); // Clear "Thinking..."
                        hasWrittenToDOM = true;
                    }
                    $thinkingContainerWrapper.show();
                    $thinkingContentElement.text($thinkingContentElement.text() + content);
                }

                function readStream() {
                    return reader.read().then(({ done, value }) => {
                        if (done) {
                            // If the stream ends, process any remaining buffer content.
                            if (buffer) {
                                if (state === 'thinking') appendThinking(buffer);
                                else appendVisible(buffer);
                                buffer = '';
                            }
                            const buttons = targetElement.querySelectorAll('.regenerate-button, .play-button');
                            buttons.forEach(button => button.disabled = false);
                            return;
                        }
                        const chunk = decoder.decode(value, { stream: true });
                        processChunk(chunk);

                        // Scroll to bottom
                        const $chatBox = $('#chat-box');
                        $chatBox.scrollTop($chatBox[0].scrollHeight);

                        return readStream();
                    }).catch(error => {
                        console.error('Error reading stream:', error);
                        targetElement.innerHTML += '<br/><span class="error-message">[Error] An error occurred while fetching the response.</span>';
                    });
                }
                readStream();
            })
            .catch(error => {
                console.error('Fetch error:', error);
                appendMessage('<strong>Error:</strong> ' + escapeHTML(error.message), 'error-message');
            });
        }

        $('#user-input').on('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Send message on button click
        $('#send-button').on('click', function() {
            sendMessage();
        });

        $('#reset-chat').on('click', function() {
            const setName = $('#set-selector').val() || 'default';
            
            if (confirm(`Are you sure you want to reset the chat history for set: ${setName}?`)) {
                const requestData = {
                    set_name: setName  // Include active set in request
                };
                
                fetch('/reset_chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => {
                            throw new Error(err.message || 'Failed to reset chat');
                        });
                    }
                    return response.json();
                })
                .then(response => {
                    if (response.status === 'success') {
                        $('#chat-content').empty();
                        appendMessage(`<strong>System:</strong> Chat history has been reset for set '${response.set_name}'.`, 'system-message');
                    } else {
                        appendMessage(`<strong>Error:</strong> ${escapeHTML(response.message)}`, 'error-message');
                    }
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                    appendMessage(`<strong>Error:</strong> ${escapeHTML(error.message)}`, 'error-message');
                });
            }
        });
    });
        function toggleThinking(button) {
            const $button = $(button);
            const $contentDiv = $button.next();
            if ($contentDiv.css('display') === 'none') {
                $contentDiv.css('display', 'block');
                $button.text('â–¼ Hide Thinking');
            } else {
                $contentDiv.css('display', 'none');
                $button.text('â–¶ Show Thinking');
            }
        }
        
        {% if not logged_in %}
        // Initialize text areas for guest session
        $('#user-system-prompt').val("{{ Config.DEFAULT_SYSTEM_PROMPT }}");
        $('#user-memory').val("");
        {% endif %}
    </script>
    <!-- jQuery and Bootstrap JS -->
    
    
</html>
